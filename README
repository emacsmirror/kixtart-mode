Overview
========

KiXtart Mode is an Emacs major mode for creating and editing KiXtart script
files.  The following features are implemented:

- Syntax highlighting for commands, functions, labels, and macros
- Indentation based on the usage of commands and parentheses
- Motion around and selection of defined functions
- Imenu support for function and label names
- ElDoc support for display of documentation
- Completion for built-in syntax (commands, functions, and macros)
- Current function name for which-function-mode and add-log functions
- Outline Mode support
- Predefined Tempo templates with optional abbrev expansion

Installation
------------

Clone this repository to a local subdirectory:

  git clone https://git.sr.ht/~mew/kixtart-mode

Within the Emacs configuration, add the path of the cloned directory to the
value of `load-path'.  The following example assumes that the repository was
cloned within a directory named "manual-packages" within the user's
".emacs.d" directory:

  (add-to-list 'load-path "~/.emacs.d/manual-packages/kixtart-mode")

Example configuration
---------------------

Assuming that the KiXtart Mode package is currently not loaded, the following
example demonstrates how to load the package, configure some basic settings,
and enable some optional features:

  ;; Load the package by searching in paths listed in `load-path'.
  (require 'kixtart-mode)

  ;; Load the default docstrings.
  (require 'kixtart-docstrings)

  ;; Set indentation and fill preferences.
  (add-hook 'kixtart-mode-hook
            (lambda ()
              (indent-tabs-mode 1)
              (setq tab-width 4)
              (setq fill-column 80)))

  ;; Set template insertion to use interactive prompts.
  (setq tempo-interactive t)

  ;; Enable `abbrev-mode' by default.
  (add-hook 'kixtart-mode-hook #'abbrev-mode)
  ;; Enable automatic abbrev expansion with the KiXtart Mode abbrev
  ;; table when outside of comments and strings.
  (setq kixtart-abbrev-table-enabled t)

  ;; Default to using the dos coding system (ASCII character set and CRLF
  ;; line endings) for file names with a .kix extension.
  (add-to-list 'file-coding-system-alist (cons "\\.kix\\'" 'dos))

Syntax highlighting
===================

Syntax highlighting is implemented for all KiXtart language keywords using
the following font-lock faces:

Keyword type            Face
-------------------------------------------------------
Command                 `kixtart-command-face'
Function (built-in)     `kixtart-function-face'
Function (definition)   `kixtart-function-name-face'
Label                   `kixtart-label-face'
Macro                   `kixtart-macro-face'
Property                `kixtart-property-face'
Variable                `kixtart-variable-face'

The additional face `kixtart-warning-face' is used to highlight portions of
text which are likely to be scripting errors.  Currently this covers two
potentially problematic cases related to KiXtart macros.  The first case is
where the macro name does not match any known macro: such macros always
evaluate to 0 and are likely the result of a spelling error.  The second case
covers a peculiarity of the original KiXtart parser, which seems to silently
discard a trailing portion of a macro name when the following criteria are
met:

1. The beginning of the macro name matches a valid KiXtart macro name

2. Immediately following this match, there are additional characters present
   which are valid for use within a macro name

3. The additional characters do not extend the match to a different (longer)
   KiXtart macro name

The trailing portion of the macro name will be highlighted as an error.

Indentation
===========

KiXtart Mode calculates the indentation level for a given line by determining
the number of script-blocks which are open around the current buffer
position, where parentheses or the following commands are deemed to open a
new or close an existing script-block:

Block-opening commands   Block-closing commands
--------------------------------------------------
DO                       UNTIL
CASE                     CASE ENDSELECT
ELSE                     ENDIF
FOR                      NEXT
FUNCTION                 ENDFUNCTION
IF                       ELSE ENDIF
WHILE                    LOOP

Note: SELECT commands are ignored for indentation purposes, to allow the
contained CASE commands to maintain the current indentation level.

The indentation offset applied to each subsequent script-block level is
determined by multiplying the value of customization variable
`kixtart-indent-offset' with the indentation level of the line which opened
the current script-block.  For example, the default value of 4 will increase
indentation in every script-block by 4 columns:

  IF $a
      *
  ENDIF

  1 + (
      *
  )

Using the indentation level of the line which opened the current script-block
allows nested script-blocks to share a line and only increase the indentation
by a single level.  For example, to create the equivalent of an AND
expression which will correctly short-circuit, it is likely preferable to use
two IF commands which are on the same line:

  IF $a IF $b
      *
  ENDIF ENDIF

Multi-line expressions
----------------------

Additional indentation is applied to a line where the previous script line
ends in a comma.  This provides automatic indentation for KiXtart commands
and expressions which expect comma-separated tokens:

  $x = 1, 2, 3,
      4, 5, 6,
      *

For tokens which are not comma-separated, it is currently not possible to
manage indentation across lines automatically.  As a workaround, additional
indentation is applied when a special comment indicates that the current line
is ending in the middle of an expression.  The presence of the special
comment ";\" appearing at the end of the previous script line will increase
the indentation of the current line.

  COPY $source ;\
      $destination ;\
      *

Motion commands
===============

KiXtart Mode assigns custom functions to `beginning-of-defun-function' and
`end-of-defun-function' and so permits navigation around and selection of
function definitions with commands such as `beginning-of-defun',
`end-of-defun', and `mark-defun'.

These commands should work well for function definitions which appear at the
top-level of the script, where the FUNCTION and ENDFUNCTION commands which
define a KiXtart function have not been indented.  If FUNCTION commands have
been indented, operation may be improved by remapping the key-binding which
would normally call `beginning-of-defun' to call `beginning-of-defun-raw' in
its place:

  (add-hook 'kixtart-mode-hook
            (lambda ()
              (local-set-key [remap beginning-of-defun]
                             'beginning-of-defun-raw)))

This will leave point at the beginning of the relevant FUNCTION command
rather than at the beginning of the line which contained the relevant
FUNCTION command.

Rather than attempt to guess where a syntactically valid KiXtart expression
begins and ends, movement by s-expression will typically move around symbols
and words.  The exception to this is where the "?" character is adjacent to
any other character classified as being symbol syntax - in this instance "?"
is dynamically reclassified as punctuation to prevent the symbol name being
extended.  For a more consistent editing experience, it is recommended to
leave white-space between usage of the "?" command and other language
keywords.

An additional navigation function is also provided in
`kixtart-up-script-block'.  This function uses the same rules of script-block
definition to move point to the buffer position which opened the current
script-block, based on its currently determined script-block level.  When at
the top-level of the script point is moved to the beginning of the buffer.
When the value of the customization variable `kixtart-block-motion-push-mark'
is non-nil the previous location will be pushed to the mark ring when the
value of point is modified.

KiXtart Mode binds `kixtart-up-script-block' to 'C-c C-u' by default.  If
`repeat-mode' is active the command may be repeated through the use of the
repeat-map binding 'u'.

Imenu support
=============

The `imenu' command provides code indexing and navigation options which allow
point to jump to indexed buffer positions.  The `imenu' menu is presented as
a list of completions which contains the names of all defined functions, as
well as a single "/Labels" submenu entry which lists all defined label names
(the "/" character is chosen as a submenu prefix because it is invalid as
part of a function name).

For very large scripts scanning for index entries can potentially be slow,
although automatic re-scanning may be preferable to manually invoking the
"*Rescan*" option from the menu.  Consider configuring `imenu-auto-rescan'
and `imenu-auto-rescan-maxout' to suitable values.

KiXtart Mode binds `imenu' to 'C-c C-j' by default.

ElDoc support
=============

ElDoc provides functions and a minor mode which can display information for
language symbols, in the echo area or within a dedicated buffer.  KiXtart
Mode implements ElDoc mode support by attempting to lookup documentation
based on the context at point, and will be activated automatically (as part
of mode initialization) after documentation has loaded.  By default, since
the original KiXtart documentation is copyrighted and attempts to contact the
author failed, no documentation is automatically loaded by inclusion within
the definition of KiXtart Mode.  Basic documentation which just describes
KiXtart syntax and macro values is provided within an accompanying file and
can be explicitly loaded if required.

To load the accompanying documentation, assuming that the file
"kixtart-docstring.el" is in a directory listed in `load-path', require the
feature `kixtart-docstrings':

  (require 'kixtart-docstrings)

Once documentation has been loaded, the ElDoc minor mode will automatically
be enabled in all new KiXtart Mode buffers, with context sensitive
documentation appearing in the echo area.  The `eldoc' function can also be
used to request the documentation for the symbol at point, and KiXtart Mode
binds this function to 'C-c C-d' by default.

The majority of options for customizing the ElDoc display will be handled by
setting ElDoc specific variables, although an additional customization
variable `kixtart-eldoc-echo-truncate' is provided to determine how much
documentation ElDoc should display when using the echo area.  By setting this
variable to an integer, only the given number of characters will be
displayed, otherwise the default value of `t' (or any other non-nil value)
specifies to only display the first paragraph.

Note: A paragraph is determined to end at the position where a documentation
string contains two new-line characters (i.e. at the position of the
substring "\n\n").

Customizing documentation search
--------------------------------

Since KiXtart Mode operates by attempting to parse the region of the buffer
which is local to point, some flexibility is required to infer which
documentation is expected to be displayed.  The current implementation will
move upwards (left) out of strings and comments and then begin calling the
functions listed in the abnormal hook `kixtart-doc-search-functions'.  If any
of the functions return a non-nil value, this result is used as the final
return value and no further functions are called.  The default configuration
will call the following functions in order:

Function: `kixtart-doc-search-at-point'

  Only consider the symbol at point.

Function: `kixtart-doc-search-before-point'

  Move point backwards through comments and white-space and then consider the
  symbol at point.  The match must be a KiXtart command or function which
  accepts arguments.

Function: `kixtart-doc-search-in-function-args'

  If point is within parentheses, move upwards (left) out of the parentheses,
  move point backwards through comments and white-space, and then consider
  the symbol at point.  The match must be a KiXtart function which accepts
  arguments.

Function: `kixtart-doc-search-command-line'

  If point is not within the indentation of the current line, move to the
  indentation column and consider the symbol at point.  The match must be a
  KiXtart command which accepts arguments, and not be for the FOR symbol
  (since the match is ambiguous without further context).

Documentation represented as structures (as defined by `cl-defstruct') and
functions present in the abnormal hook `kixtart-doc-search-functions' will
determine which structures are selected to be displayed.  The return value of
each function is a cons cell, with the first value being the upper-case form
of the symbol which was matched, and the second value being a list of
documentation structures which will be converted to text and concatenated
together, separated by a single new-line character.

Note: The requirement for dealing with multiple matches is a requirement to
ensure that all matches for ambiguous KiXtart commands such as FOR and NEXT
are given a chance to be displayed.

Customizing documentation
-------------------------

At the most basic level of customization, it is possible to register
additional documentation using the existing documentation structures and
helper functions.  The macro `kixtart-doc-register' can be used to register
multiple documentation entries for a given structure type, taking the
constructor name as the first argument and processing the body as one or more
documentation specifications.  Each specification is itself a list, where the
first element is a symbol or list of symbols to be passed to the constructor
as the keyword argument `:symbols', and all other elements are passed as
additional constructor arguments.  Symbols should be registered in upper-case
in order for matching to succeed.

At a more general level, the mechanisms for finding and formatting
documentation are implemented independently and may be overridden or
replaced.  It is possible to use user defined structures in place of the
original ones, although to remain compatible with existing documentation
search functions, any new structures should:

- Be compatible with the predicate functions `kixtart-doc-command-p',
  `kixtart-doc-function-p', and `kixtart-doc-macro-p'

- Be compatible with the generic method `kixtart-doc-string', which returns
  the structure as a string (for macros this requires a slot named
  `description' which describes the macro value, for commands and functions
  this requires a slot named `syntax' which describes the syntax)

- Implement a slot named `symbols' which contains the list of symbols to be
  matched

- Implement a slot named `final' which determines which of the symbols in the
  `symbols' slot list expect to be followed by additional syntax

The value of the `final' slot should be one of the following:

- `nil', which indicates that all symbols expect to be followed by additional
  syntax

- `t', which indicates none of the symbols expect to be followed by
  additional syntax

- `first', which indicates that all symbols in the `symbols' slot except the
  first expect to be followed by additional syntax

- `last', which indicates that all symbols in the `symbols' slot except the
  last expect to be followed by additional syntax

- A list of symbols which do not expect to be followed by additional syntax

The most direct way to implement compatibility with existing search
functions, and just customize documentation content or formatting, is to
declare any new structures as inheriting from `kixtart-doc-command',
`kixtart-doc-function', or `kixtart-doc-macro'.

Customization examples
----------------------

Prevent documentation from being displayed for symbols which are only matched
by being at the beginning of the current line:

  (remove-hook 'kixtart-doc-search-functions
               #'kixtart-doc-search-command-line)

Register documentation for two KiXtart user-defined functions which takes no
arguments:

  (kixtart-doc-register kixtart-make-doc-function
    (_SETUPDEBUG :syntax "_SetDebug ()" :final t)
    (_SETUPGLOBALS :syntax "_SetupGlobals ()" :final t))

Register documentation for a single KiXtart user-defined function which takes
arguments:

  (kixtart-doc-register kixtart-make-doc-function
    (LOG :syntax "Log ($message, optional $level)"))

Register extended documentation which contains additional information:

  ;; Declare a new structure to represent a command, including the default
  ;; slots, and extended with additional slots suitable for use with the
  ;; official KiXtart documentation.
  (cl-defstruct (kixtart-manual-command
                 (:include kixtart-doc-command)
                 (:constructor kixtart-make-manual-command)
                 (:copier nil))
    (action nil :type string)
    (examples nil :type string)
    (parameters nil :type string)
    (remarks nil :type string))

  ;; Require the `eieio' feature to allow convenient slot access with the
  ;; `with-slots' macro.
  (require 'eieio)

  ;; Declare a method which specializes on the new structure type and returns
  ;; it as a string.  Assume that the default documentation is not loaded so
  ;; that the concatenating of multiple symbol matches is not relevant.
  (cl-defmethod kixtart-doc-string ((doc kixtart-manual-command))
    "Return DOC as a string.
  DOC is a `kixtart-manual-command' structure."
    (concat
     ;; Get the docstring from the structure which was included.  This is a
     ;; choice to re-use existing code to convert the syntax slot to a string
     ;; instead of reading the slot value.
     (cl-call-next-method)
     ;; Build a new string based on the additional slot values.
     (with-slots (action examples parameters remarks) doc
       (concat
        (and action (format "\n\nAction\n\n%s" action))
        (and examples (format "\n\nExamples\n\n%s" examples))
        (and parameters (format "\n\nParameters\n\n%s" parameters))
        (and remarks (format "\n\nRemarks\n\n%s" remarks))))))

  ;; Register new documentation with the new type.
  (kixtart-doc-register kixtart-make-manual-command
    (GOTO
     :action "Description of the GOTO command's action."
     :examples "Example of GOTO command's use."
     :remarks "Remarks on GOTO command."
     :syntax "GOTO expression"
     :parameters "Details of the GOTO command's parameters."))

Symbol completion
=================

In-buffer completion of all built-in KiXtart keywords (commands, functions,
and macros) is available through the standard completion-at-point mechanism,
and will present completion candidates when the `completion-at-point'
function is called.

All keywords are stored internally using "PascalCase" to allow the case of
completion candidates to be customized.

The customization variable `kixtart-completion-list-hook' is a hook which may
be used to customize the completion keywords list before it is sent to the
completion interface.  At the time that the hook functions are called, the
dynamically bound variable `kixtart-completion-list' will have the value of
the completion list, and the dynamically bound variable
`kixtart-completion-input' will have a copy of the input string which is
being completed.  The hook functions are free to modify theses values.  By
default, the following two functions are already added to the hook:

Function: `kixtart-completion-upcase-macros'

  Convert all macro names in the completion list to uppercase.

Function `kixtart-completion-add-crlf-commands'

  If the string being completed is a sequence of two or more "?" characters
  (i.e. multiple CRLF output commands which have defined a single pair of
  symbol boundaries), append the string to the front of the completion list.

The experience with the default hook functions in-place is that:

- Completion candidates for commands and functions will be displayed and
  inserted in "PascalCase"

- Completion candidates for macros will be displayed and inserted in
  uppercase

- Attempting to complete a single symbol which is a sequence of "?"
  characters will always return a single match

The customization variable `kixtart-completion-annotation-function' can be
used to modify how the completion candidates are annotated in the completions
interface.  The function is expected to accept a single argument, the string
of the completion candidate, and return the string to be use as the
annotation.  The default value of this variable is the following function:

Function: `kixtart-completion-annotate-macros'

  When the completion candidate appears to be a KiXtart macro name, attempt
  to find a matching documentation structure in the registered documentation
  (see: ElDoc support) and return the `description' slot value of the
  `kixtart-doc-macro' structure.  Otherwise return nil.

Note: The presence of the completion-at-point implementation will replace the
default behaviour of completing symbols using a TAGS file.  To reliably use
both completion functions, without having to know in advance which will be
the one which gets activated by matching the input, there are two options:

1. Invoke the TAGS completion separately by using the `complete-tag' command

2. Use a third party package to call both completion functions, merge the
   results, and present a single list of completion candidates

If taking the second option, the recommended solution is to install the
"Cape" package and replace the completion functions with the result of
calling the completion merging function `cape-capf-super':

  (add-hook 'kixtart-mode-hook
            (lambda ()
              (setq-local completion-at-point-functions
                          (list (cape-capf-super
                                 #'tags-completion-at-point-function
                                 #'kixtart-completion-at-point-function)))))

Current function name
=====================

The function `kixtart-current-defun' will return the name of the user-defined
KiXtart function which currently surrounds point, or nil if point is
currently outside of a function.  This function is also used internally to
provide support for:

- `add-log' functions, which allow the current function name to be
  automatically added to change log entries

- `which-function-mode', a minor mode which displays the current function
  name in the mode-line

Note: The customization variable `kixtart-which-function-default-name' is
available and can override the function name which is displayed when point is
currently outside of a function.  Setting this value to nil will revert to
the original `which-function-mode' behavior of displaying a name retrieved
from Imenu data.

Outline Mode support
====================

Outline Mode is major mode intended to edit outline-format documents with
selective display.  The same functionality is also available through
alternate key-bindings using the minor mode version, enabled by invoking
`outline-minor-mode'.

KiXtart Mode defines Outline Mode settings by borrowing some conventions for
headings and their associated depth from the built-in Lisp mode.  Two types
of headings are defined:

- Comments created by 3 or more ";" characters at the beginning of a line,
  followed by at least 1 white-space character

- FUNCTION commands at the beginning of a line

The depth of comment-based headings is determined by subtracting 2 from the
number of ";" characters which were used.  For example, the following
comments define Outline Mode headings for the first 3 levels:

  ;;; Level 1 heading
  ;;;; Level 2 heading
  ;;;;; Level 3 heading

The depth of FUNCTION command-based headings is not variable: all headings of
this type have the maximum possible value for their depth, meaning that
selective display of function definitions cannot affect selective display of
comment-based headings.

Templates
=========

Tempo templates for inserting command-defined script-blocks are
predefined and can be inserted by:

- Invoking Tempo template functions directly
- Invoking KiXtart Mode aliases for Tempo template functions
- Tempo functionality such as `tempo-complete-tag'
- Abbrev expansion

For direct use of Tempo functionality, the following key-bindings exist by
default:

'C-c C-t C-b'
  `tempo-backward-mark'

'C-c C-t C-f'
  `tempo-forward-mark'

'C-c C-t C-t'
  `tempo-complete-tag'

Note: Tempo tag completion will match a template tag even when the match is a
prefix of a longer template tag.  For example, an input of "i" or "if" will
expand based on the template tag "if", even though it is a prefix of the
longer template tag "ifelse".  To expand based on the template tag "ifelse"
the input would have to be "ife", "ifel", "ifels", or "ifelse".

Note: For use of interactive prompts when inserting a template, customize the
value of 'tempo-interactive'.

Regardless of how a template has been inserted the customization variable
`kixtart-template-insert-newline' determines whether template insertion will
include a final newline character.  A non-nil value will cause a newline to
be inserted.  When set to a function (as determined by `functionp') the
result of the calling that function should determines the result by returning
a nil or non-nil value.  The default value is `eobp' which has the effect of
preserving the final newline when templates are inserted at the end of the
buffer.

Abbrev expansion
----------------

The KiXtart Mode abbrev table will be considered for use when the following
conditions are true:

1. `kixtart-abbrev-table-enabled' has a non-nil value
2. Point is currently not within a comment or a string

Expansion of the predefined template tags can be performed manually with
functions such as `expand-abbrev'.  For automatic expansions, this can be
achieved by enabling the abbrev minor mode (`abbrev-mode') in the current
buffer.  It is likely convenient to automatically enable `abbrev-mode' in all
KiXtart Mode buffers:

  (add-hook 'kixtart-mode-hook #'abbrev-mode)

Template case control
---------------------

Since all template insertion is done either directly or indirectly through
Tempo functions, customization of inserted text can be achieved by modifying
the Tempo configuration; if template content should be converted to
upper-case, this can be achieved by adding the `upcase' function to
`tempo-insert-string-functions':

  (add-hook 'kixtart-mode-hook
            (lambda ()
              (add-to-list (make-local-variable
                            'tempo-insert-string-functions)
                           #'upcase)))

Predefined templates
--------------------

KiXtart Mode defines aliases to predefined Tempo template functions which
will insert commonly used command-defined script-blocks.

Note: Template contents are written using "PascalCase" for language keywords;
the first letter of all words within KiXtart commands are capitalized (for
example, "EndIf" rather than "ENDIF" or "endif").  This allows the case to
customised by optionally down-casing or up-casing the template as it is
inserted.

Function: `kixtart-template-ifelse'

    If *

    Else

    EndIf

  Expands from string "ifelse".
  Bound to 'C-c C-t I' by default.

Function: `kixtart-template-case'

    Case *

  Expands from string "case".
  Bound to 'C-c C-t c' by default.

Function: `kixtart-template-do'

    Do
        *
    Until

  Expands from string "do".
  Bound to 'C-c C-t d' by default.

Function: `kixtart-template-foreach'

    For Each * In

    Next

  Expands from string "foreach".
  Bound to 'C-c C-t e' by default.

Function: `kixtart-template-for'

    For $* =  To  Step

    Next

  Expands from string "for".
  Bound to 'C-c C-t f' by default.

Function: `kixtart-template-if'

    If *

    EndIf

  Expands from string "if".
  Bound to 'C-c C-t i' by default.

Function: `kixtart-template-else'

    Else
        *

  Expands from string "else".
  Bound to 'C-c C-t l' by default.

Function: `kixtart-template-select'

    Select
    Case *

    EndSelect

  Expands from string "select".
  Bound to 'C-c C-t s' by default.

Function: `kixtart-template-function'

    Function *()

    EndFunction

  Expands from string "function".
  Bound to 'C-c C-t u' by default.

Function: `kixtart-template-while'

    While *

    Loop

  Expands from string "while".
  Bound to 'C-c C-t w' by default.

Closing open blocks
===================

As an alternative to inserting fully-templated code into the buffer, the
command `kixtart-close-command-block' will insert a KiXtart command which can
close the currently open script block, where an open block is determined by
looking backwards from point.  Repeatedly invoking the command will cycle
through the possible options, with the previously inserted option being
removed.  When no further options are available the previously inserted
option will be removed and no new option will be inserted.

The case of the inserted KiXtart command will be determined by the case of
the block opening.  For example, "WHILE" will be closed by "LOOP", "while"
will be closed "loop", and any other case-variation will be closed by "Loop".

KiXtart Mode binds `kixtart-close-command-block' to 'C-c C-c' by default.  If
`repeat-mode' is active the command may be repeated through the use of the
repeat-map bindings 'C-c' and 'c'.
